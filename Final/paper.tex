\documentclass[runningheads]{llncs}
\usepackage{llncsdoc}
\usepackage{makeidx}

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% Preamble: Packages required for the paper
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{epstopdf}
\makeindex
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


\begin{document}

\title{Evolving Motion Machines}

\author{Nathan Douglas\\10160679}


\institute{ 
\email{nathan.douglas@ucalgary.ca}
}

\maketitle

% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% ABSTRACT
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

% \begin{abstract} 
% Describe in one or two sentences what your project is about.
% \end{abstract}

\section{Introduction}
\label{sec:Introduction}
Emergent computing has been previously used in many areas before.
In particular, the iterative approach taken by both evolutionary and genetic systems has repeatedly proven its' ability in several domains.
The gradual approximation technique for a given goal function can create very interesting, efficient, and effective solutions.
Further, some implementations have been remarkably effective in modelling real world behaviour.
With each implementation and domain being so unique, there exists plenty of room for continued application of these techniques.

This research aims to expand on the existing pool of implementations using emergent approaches.
General approaches are designed to either recreate natural behaviours or search for new optimal policies.
This is done first by creating a proposed solution, or genotype, with some initial value selected for each variable part of the solution.
The genotype or genotypes are then implemented and become their resulting phenotypes, which are then evaluated.
Finally, the genotypes which created the most effective phenotypes are mutated slightly, and repeat the process of instantiation and evaluation.
This creates the iterative process of searching for better and better solutions to a given goal function.

However, most research surrounding emergent computing is more focused on behaviours.
The structure of the phenotype is generally static, while the actions and reasoning are given more careful attention.
This system looks to use evolutionary strategies in a different way, focussing more on the resulting structure of a solution.
To this end, a rather simple goal function is used: simply move as much as possible.
The more complex aspect is in the genotype's large influence over the structure of the agent it generates.

Agents in this system are created from small, atomic pieces that join together to create larger collective structures.
Atoms have different simple geometric shapes, different types of motion, and a variable direction and intensity of the motion.
While atoms can mutate this direction and intensity as part of their evolutionary loop, they can also mutate additional adjoining atoms.
These new pieces attach to their parent using a physical link, creating a large branching tree structure.
With each atom still moving independently, this creates large agents with many independently moving subtrees.

This high degree on independence between subtrees creates a very dynamic structure with many different potential solutions.
Ideally this variability allows for interesting results.
As with evolution in nature, this system intends to mimic the variation in structure of life on earth.
As is shown below, this goal is somewhat met but the system itself is still too premature to be a comparable analog to natural selection.

\section{Implementation}
With the goal of moving as far as possible in each generation, an appropriate environment is needed to evaluate in.
Further, within the environment there are a list of features that must be included to support the evaluation.
First and foremost is the ability to deserialize a given genotype into a phenotype, or agent, to be evaluated.
Also needed is the inverse serialization ability.
Then, agents need some physics simulator to operate within and source the evaluation of exactly how much distance has been covered.
To this end, the Unity Engine is used as it provides a simple object instantiation scheme and a built-in physics simulation engine.

\subsection{Phenotypical Agent Structure}
Unity's simple object instantiation scheme is used to create the agent's constituent atoms.
Unity contains simple geometric shapes including spheres, cubes, and capsules.
Atoms can be one of these three shapes, which are scaled individually to make all atoms approximately the same size.
The scaling factor is different for each shape, as the shapes are different sizes by default.
The factor is set such that each shape has no cross section with a width larger than 1 meter as defined by Unity's measurement system.
This way, adjacent atoms can be instantiated 1 meter apart and do not overlap, as overlapping objects cause unexpected behaviour in the physics simulation.

Agents themselves are collections of these atoms.
Specifically, an agent is a 3-dimensional cubic grid, where each item in the grid can be either an atom or simply empty.
Atoms adjacent to each other within the grid can be physically linked to each other with invisible joints. 
These joints force the two connected atoms to be a static distance apart, mostly restriciting them from moving either closer or further apart.
The distance between two joined atoms is not completely static though, as Unity's physics engine allows the joints to stretch, compress, and bend to a small degree.

Each individual atom may either remain static or rotate around the center of its space in the grid.
This is the main way that an agent is able to move, outside of gravity causing an unbalanced agent to topple.
Further, the joint based structure combined with individual atom rotations allows for complex agent movement.
A rotating atom attached to another atom causes the attached atom to leave it's initial space in the grid and orbit the rotating atom.
Intuitively, this works like a fan.
A center piece rotates in place, and the blades are forced in a cyclic motion around the center.
The direction and force of rotation varies between atoms, with direction also controlling orientation for both static and non-static agents.

\subsection{Genotypical Agent Structure}

The genotypical structure of agents is very similar to the phenotypical instantiation.
Agents are stored as 3-dimensional arrays with each index containing specific data about its corresponding atom.
Each atom is stored as a simple collection of four values; 
two integers for the shape and motion types, a float for the motion's force, and a vector containing the rotation direction.

Agents are structured this way partly because it makes serialization and deserialization simpler.
Serialization of agents converts the array of atoms into one long string.
First, atoms are serialized using Unity's built in serialization tools which simply convert the four fields described above into json format.
The array is then flattened to a 1-dimensional equivalent.
Each atom's json representation is then added to the agent's total serialized format, using semicolons to delimit the json strings.
Deserialization simply reverses this process, retrieving the necessary information for each atom from the serialized string.

The major reason for structuring agent's this way is that it is simpler to create the phenotype given this representation.
Stored as an array, detecting conflicting atoms is as simple as checking the index in question.
This is crucial for agents that modify their own structure, as is outlined in 2.3.
It is also a very simple representation to work with, although it does require more space than is aboslutely necessary.
However, alternative approaches to indexing spaces in the array that also determine conflicting neighbours in 3-dimensions adds unnecessary complexity to the structure.

Within the array, atoms are joined in a tree-based structure.
Each agent has exactly one atom that is not joined to a parent atom, essentially creating a root node.
This root node can then be joined to each atom in its von Neumann neighbourhood.
The joints used work similarly to ball and socket joints, allowing full rotation around any axis but keeping distance between each atom constant.
In this way, a \textit{parent} atom applies rotational force to its \textit{child} atoms, but not vice versa.
This tree structure acyclically joins all atoms together, creating a single large agent.

\subsection{Mutation System}

\subsection{Evaluation System}

\section{Results}

\section{Discussion}

\section{Future Work}

%different distance measurement (relative angle)
%different terrain types
%different evaluation point (center of mass)
%cyclic joints in agent structure.
\section{Conclusion}

\end{document}